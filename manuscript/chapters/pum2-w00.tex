\chapter{Organizacja kursu i nawigacja Compose (Wyk≈Çad 0)}

\section{Podstawowe informacje o kursie}
\subsection{Organizacja kursu}
Zajƒôcia obejmujƒÖ ≈ÇƒÖcznie 75 godzin pracy studenta, z czego 15 godzin przeznaczonych jest na wyk≈Çady (45 minutowy wyk≈Çad na tydzie≈Ñ), a 30 godzin na zajƒôcia laboratoryjne. Dodatkowo przewidziano 30 godzin pracy w≈Çasnej studenta, niezbƒôdnej do samodzielnego opracowania materia≈Çu, przygotowania projekt√≥w oraz pog≈Çƒôbiania wiedzy. Kurs ko≈Ñczy siƒô uzyskaniem 3 punkt√≥w ECTS. 

W trakcie zajƒôƒá wykorzystywane sƒÖ materia≈Çy dydaktyczne dostƒôpne pod adresem: \url{https://github.com/RafLew84/ProgUM}.  ObowiƒÖzkowa i zalecana literatura:
\begin{itemize}
\item Dokumentacjƒô jƒôzyka Kotlin (\url{https://kotlinlang.org/docs/home.html}
) 
\item oficjalne kursy programowania aplikacji mobilnych dostƒôpne na platformie Android Developers (\url{https://developer.android.com/courses}).
\end{itemize}

\subsection{Zasady zaliczenia}
\begin{itemize}
  \item Warunkiem zaliczenia laboratorium jest uzyskanie \textbf{oceny pozytywnej z list zada≈Ñ}.
  \item Na zajƒôcia przewidzianych jest \textbf{5 list zada≈Ñ}.
  \item Z ka≈ºdej listy wystawiana jest \textbf{osobna ocena}.
  \item \textbf{Nie jest konieczne} zaliczenie wszystkich list aby otrzymaƒá ocenƒô pozytywnƒÖ z laboratorium. Dopuszczalne jest nieoddanie/niezaliczenie \textbf{jednej listy} - za tƒÖ listƒô otrzymuje siƒô ocenƒô 2,0.
  \item Ka≈ºda lista posiada informacjƒô o \textbf{liczbie} punkt√≥w wymaganych na konkretnƒÖ ocenƒô
  \item Ka≈ºda lista posiada \textbf{termin zwrotu}.
  \item Za \textbf{ka≈ºdy tydzie≈Ñ op√≥≈∫nienia} otrzymana ocena jest \textbf{obni≈ºana o 1,0}.
  \item Listy oddawane sƒÖ \textbf{podczas zajƒôƒá laboratoryjnych}. 
  \item Do ka≈ºdej listy prowadzƒÖcy \textbf{zadaje 4 pytania}.
  \item Liczba punkt√≥w za listƒô jest przyznawana na podstawie \textbf{poprawno≈õci wykonania zada≈Ñ} oraz \textbf{odpowiedzi ustnej}.
  \item Ocena ko≈Ñcowa jest \textbf{≈õredniƒÖ arytmetycznƒÖ} ze \textbf{wszystkich ocen} z list.
  \item Na ocenƒô 3,0 \textbf{wymagana jest} ≈õrednia co najmniej 3,0.
  \item Na zajƒôciach laboratoryjnych dopuszczalne sƒÖ \textbf{trzy nieobecno≈õci nieusprawiedliwione}.
\end{itemize}

\subsection{Tre≈õci Programowe}
\begin{enumerate}
  \item Zasady zaliczenia, Tre≈õci Programowe, Zaawansowana Nawigacja.
  \item Wprowadzenie do WielowƒÖtkowo≈õci: Coroutines. WƒÖtek g≈Ç√≥wny.
  \item Coroutines. Wsp√≥≈Çbie≈ºno≈õƒá, R√≥wnoleg≈Ço≈õƒá, Asynchroniczno≈õƒá.
  \item Podstawy Architektury Aplikacji: Wzorce MVx (MVC, MVP, MVVM).
  \item Reaktywne ZarzƒÖdzanie Stanem: Flow, StateFlow, SharedFlow.
  \item Zaawansowane ZarzƒÖdzanie Stanem: withContext, StateIn, ShareIn, FlowOn, combine.
  \item Coroutines: Kana≈Çy - Asynchroniczna Wymiana Danych Miƒôdzy Coroutines.
  \item Zapis Danych do Pliku: SharedPreferences, DataStore.
  \item Baza Danych SQLite + ROOM: Entity, Dao, Database, CRUD, Operacje Asynchroniczne.
  \item Praca z Zewnƒôtrznymi ≈πr√≥d≈Çami Danych: Retrofit2, Operacje Asynchroniczne.
  \item Wstrzykiwanie Zale≈ºno≈õci: Dagger, Hilt.
  \item Czysta Architektura - Warstwa Domeny i Wzorzec Use Case.
  \item Wzorzec Single Source of Truth - Strategia Offline Caching.
  \item Backend w Chmurze: Wprowadzenie do Firebase i Firestore
\end{enumerate}

\subsection{Android Studio - Rozpoczƒôcie i konfiguracja projektu}
Podczas zajƒôƒá tworzymy projekty w Android Studio, w Kotlinie, z interfejsem budowanym w Jetpack Compose (bez widok√≥w XML). Najpro≈õciej zaczƒÖƒá od kreatora: \texttt{New Project $\rightarrow$ Empty Activity}. Ustaw \texttt{Language: Kotlin}, \texttt{Minimum SDK: 28+} i zaakceptuj ustawienia. Taki szablon tworzy gotowy projekt z poprawnƒÖ konfiguracjƒÖ Compose i przyk≈Çadowym \texttt{setContent \{ ‚Ä¶ \}}. 

\textbf{UWAGA!!!} Nie u≈ºywaj Empty Views Activity - to rozpoczyna projekt oparty o \textit{widoki}, gdzie ui definiujemy jako pliki XML.

\subsection{Dodawanie zale≈ºno≈õci}
Wszystkie zale≈ºno≈õci dopisujemy w bloku \texttt{dependencies \{ ‚Ä¶ \}} pliku \texttt{build.gradle(.kts)(Module:App)}. Przyk≈Çadowy plik:

\textbf{UWAGA!!!!} NIE KOPIUJ PLIK√ìW KONFIGURACYJNYCH - zawierajƒÖ informacje UNIKALNE DLA PROJEKTU !!!!

\begin{minted}{kotlin}
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
}

android {
    namespace = "com.example.test"
    compileSdk = 36

    defaultConfig {
        applicationId = "com.example.test"
        minSdk = 28
        targetSdk = 36
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
    buildFeatures {
        compose = true
    }
}

dependencies {
    // tutaj dodajemy zale≈ºno≈õci

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
}
\end{minted}

\textbf{UWAGA!!!} Pamiƒôtaj aby wykonaƒá \textbf{synchronizacjƒô} (\ref{fig:figura-1}) projektu po jakiejkolwiek zmianie w plikach z katalogu \texttt{gradle}

\begin{figure}[htbp]
    \includegraphics{fig/pum2-w00-fig1.png}
    \caption{Okno programu z widokiem na plik konfiguracyjny.}
    \label{fig:figura-1}
\end{figure}

\subsection{Szuflada Nawigacyjna}
W tej czƒô≈õci skupimy siƒô na praktycznej implementacji nawigacji w aplikacji Jetpack Compose. Zak≈ÇadajƒÖc, znajomo≈õƒá podstawowych blok√≥w konstrukcyjnych: NavHost i NavController, przyjrzymy siƒô, jak zintegrowaƒá je z zaawansowanymi komponentami Material 3, takimi jak szuflada nawigacyjna.

Przeanalizujmy kod, kt√≥ry implementuje jeden z najczƒôstszych wzorc√≥w nawigacyjnych w aplikacjach mobilnych: szufladƒô nawigacyjnƒÖ (znanƒÖ r√≥wnie≈º jako \textit{hamburger menu})(\ref{fig:Figura 2}).

\begin{figure}[htbp]
    \includegraphics[width=0.7\textwidth]{fig/pum2-w00-fig2.png}
    \caption{Szuflada nawigacyjna.}
    \label{fig:Figura 2}
\end{figure}

Za≈ÇƒÖczony kod to kompletna, choƒá minimalistyczna, aplikacja demonstrujƒÖca ≈ÇƒÖczenie komponent√≥w \texttt{Jetpack Navigation}, \texttt{Scaffold} oraz \texttt{ModalNavigationDrawer}. Przyjrzyjmy siƒô jej kluczowym elementom krok po kroku.

Aby m√≥c pracowaƒá z \texttt{compose navigation} musimy dodaƒá odpowiedniƒÖ \textbf{zale≈ºno≈õƒá} do projektu

\begin{minted}{kotlin}
dependencies {
    implementation("androidx.navigation:navigation-compose:2.9.2")
}
\end{minted}

Pierwszym elementem jest \textbf{centralizacja tras nawigacyjnych} w obiekcie \texttt{data object AppDestinations}.

\begin{minted}{kotlin}
data object AppDestinations {
    const val HOME = "home"
    const val PROFILE = "profile"
    const val SETTINGS = "settings"
}
\end{minted}


Centralizacja zapewnia bezpiecze≈Ñstwo typ√≥w, u≈Çatwia refaktoryzacjƒô (zmieniamy nazwƒô w jednym miejscu).

W aplikajci zagnie≈ºd≈ºamy kilku komponent√≥w . Hierarchia wyglƒÖda nastƒôpujƒÖco:

\begin{minted}{kotlin}
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainApp() {
    val navController = rememberNavController()
    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            DrawerContent(navController = navController, drawerState = drawerState)
        }
    ) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("Aplikacja z SzufladƒÖ") },
                    navigationIcon = {
                        IconButton(onClick = {
                            scope.launch { drawerState.apply { if (isClosed) open() else close() } }
                        }) { Icon(Icons.Filled.Menu, contentDescription = "Menu") }
                    }
                )
            }
        ) { paddingValues ->
            NavHost(
                navController = navController,
                startDestination = AppDestinations.HOME,
                modifier = Modifier.padding(paddingValues)
            ) {
                composable(AppDestinations.HOME) { HomeScreen() }
                composable(AppDestinations.PROFILE) { ProfileScreen() }
                composable(AppDestinations.SETTINGS) { SettingsScreen() }
            }
        }
    }
}
\end{minted}

\begin{enumerate}
  \item \texttt{ModalNavigationDrawer}: Jest to komponent najwy≈ºszego poziomu, kt√≥ry zarzƒÖdza logikƒÖ pokazywania i ukrywania wysuwanej szuflady. Przyjmuje on dwa kluczowe parametry:
  \begin{itemize}
    \item \texttt{drawerState}: Stan szuflady (otwarta/zamkniƒôta).
    \item \texttt{drawerContent}: Funkcja kompozycyjna definiujƒÖca zawarto≈õƒá samej szuflady (\texttt{DrawerContent}).
  \end{itemize}
  \item \texttt{Scaffold}: Umieszczony wewnƒÖtrz \texttt{ModalNavigationDrawer}, \texttt{Scaffold} zapewnia standardowƒÖ strukturƒô ekranu. W naszym przypadku u≈ºywamy go do zdefiniowania \texttt{topBar} (g√≥rnego paska aplikacji).

  \item \texttt{NavHost}: Na ko≈Ñcu, wewnƒÖtrz \texttt{Scaffold}, umieszczamy nasz \texttt{NavHost}. To on zarzƒÖdza faktycznƒÖ podmianƒÖ tre≈õci ekranu (\texttt{HomeScreen, ProfileScreen} itd.). Zwr√≥ƒámy uwagƒô na kluczowe powiƒÖzanie: \texttt{modifier = Modifier.padding(paddingValues)}. Przekazujemy tu wype≈Çnienie (\texttt{paddingValues}) otrzymane ze \texttt{Scaffold}, co zapewnia, ≈ºe nasza tre≈õƒá nie zostanie przys≈Çoniƒôta przez \texttt{TopAppBar}.
\end{enumerate}

W funkcji \texttt{MainApp} zauwa≈ºymy trzy kluczowe \textbf{zmienne stanu}.

\begin{minted}{kotlin}
val navController = rememberNavController()
val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
val scope = rememberCoroutineScope()
\end{minted}

Pierwsze dwie sƒÖ oczywiste: jedna zarzƒÖdza \textbf{stosem nawigacji}, druga \textbf{stanem szuflady}. Ale dlaczego potrzebujemy \texttt{scope}?

Odpowied≈∫ le≈ºy w naturze \texttt{drawerState}. Metody \texttt{drawerState.open()} i \texttt{drawerState.close()} sƒÖ funkcjami zawieszajƒÖcymi (\texttt{suspend functions}) - wiƒôcej o tych funkcjach w kolejnych rozdzia≈Çach. Nie mo≈ºna ich po prostu wywo≈Çaƒá z dowolnego miejsca ‚Äì muszƒÖ byƒá uruchomione wewnƒÖtrz \textbf{korutyny}. Zmiana \texttt{drawerState} automatycznie spowoduje \textbf{rekompozycjƒô} i wizualne otwarcie szuflady.

\begin{minted}{kotlin}
{scope.launch { drawerState.apply { if (isClosed) open() else close() } }})
\end{minted}

Przejd≈∫my do zarzƒÖdzania nawigacjƒô z wnƒôtrza szuflady. W funkcji \texttt{MainApp} dodali≈õmy \texttt{ModalNavigationDrawer}, kt√≥ry posiada parametr \texttt{drawerContent} - jako ten parametr przekazujemy funkcjƒô \texttt{DrawerContent}, zajrzyjmmy do jej wnƒôtrza:

\begin{minted}{kotlin}
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DrawerContent(navController: NavController, drawerState: DrawerState) {
    val scope = rememberCoroutineScope()

    ModalDrawerSheet {
        Column(modifier = Modifier.padding(16.dp)) {
            Text("Menu", style = MaterialTheme.typography.headlineSmall)
            Spacer(modifier = Modifier.height(16.dp))

            NavigationDrawerItem(
                icon = { Icon(Icons.Default.Home, contentDescription = "Strona g≈Ç√≥wna") },
                label = { Text("Strona g≈Ç√≥wna") },
                selected = false,
                onClick = {
                    navController.navigate(AppDestinations.HOME)
                    scope.launch { drawerState.close() }
                }
            )
            NavigationDrawerItem(
                icon = { Icon(Icons.Default.Person, contentDescription = "Profil") },
                label = { Text("Profil") },
                selected = false,
                onClick = {
                    navController.navigate(AppDestinations.PROFILE)
                    scope.launch { drawerState.close() }
                }
            )
            NavigationDrawerItem(
                icon = { Icon(Icons.Default.Settings, contentDescription = "Ustawienia") },
                label = { Text("Ustawienia") },
                selected = false,
                onClick = {
                    navController.navigate(AppDestinations.SETTINGS)
                    scope.launch { drawerState.close() }
                }
            )
        }
    }
}
\end{minted}

WewnƒÖtrz \texttt{ModalDrawerSheet} definiujemy elementy bƒôdƒÖce wy≈õwietlane w szufladzie jako \texttt{NavigationDrawerItem}. Jest to element zaprojektowany wed≈Çug tego samego wzorca (\textit{slot-based-layouts}). Posiada zdefiniowane \textit{sloty} w kt√≥re mo≈ºna wstawiƒá elementy (\texttt{icon, label, divider}), upraszczajƒÖc tworzenie ca≈Çego layoutu.
Po klikniƒôciu elementu w szufladzie wykonujemy dwie akcje:
\begin{itemize}
  \item \textbf{Nawigujemy}: Wywo≈Çujemy \texttt{navController.navigate()}, aby zmieniƒá zawarto≈õƒá \texttt{NavHost}.
  \item \textbf{Zamykamy szufladƒô}: Uruchamiamy korutynƒô (\texttt{scope.launch}), aby wywo≈Çaƒá \texttt{drawerState.close()}.
\end{itemize}

Jak widzimy, nawigacja w Jetpack Compose to znacznie wiƒôcej ni≈º tylko wywo≈Çywanie \texttt{navController.navigate()}. To przemy≈õlana integracja kontrolera nawigacji z innymi komponentami interfejsu, takimi jak \texttt{ModalNavigationDrawer}. Istotnym elementem jest zrozumienie, jak zarzƒÖdzaƒá wieloma stanami (\texttt{navController, drawerState}) oraz jak obs≈Çugiwaƒá \textbf{asynchroniczne wywo≈Çania} (funkcje \texttt{suspend} do otwierania/zamykania szuflady) za pomocƒÖ odpowiednich narzƒôdzi, takich jak \texttt{rememberCoroutineScope}.

Na kolejnych wyk≈Çadach zag≈Çƒôbimy siƒô w korutyny, kt√≥re sƒÖ fundamentem dzia≈Çania tego przyk≈Çadu.


\subsubsection{pe≈Çny kod przyk≈Çadu}

\begin{minted}{kotlin}
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            MyApplicationTheme {
                MainApp()
            }
        }
    }
}

data object AppDestinations {
    const val HOME = "home"
    const val PROFILE = "profile"
    const val SETTINGS = "settings"
}

@Composable
fun HomeScreen() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text("Strona G≈Ç√≥wna", fontSize = 24.sp)
    }
}

@Composable
fun ProfileScreen() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text("Profil U≈ºytkownika", fontSize = 24.sp)
    }
}

@Composable
fun SettingsScreen() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text("Ustawienia", fontSize = 24.sp)
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainApp() {
    val navController = rememberNavController()
    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            DrawerContent(navController = navController, drawerState = drawerState)
        }
    ) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("Aplikacja z SzufladƒÖ") },
                    navigationIcon = {
                        IconButton(onClick = {
                            scope.launch { drawerState.apply { if (isClosed) open() else close() } }
                        }) { Icon(Icons.Filled.Menu, contentDescription = "Menu") }
                    }
                )
            }
        ) { paddingValues ->
            NavHost(
                navController = navController,
                startDestination = AppDestinations.HOME,
                modifier = Modifier.padding(paddingValues)
            ) {
                composable(AppDestinations.HOME) { HomeScreen() }
                composable(AppDestinations.PROFILE) { ProfileScreen() }
                composable(AppDestinations.SETTINGS) { SettingsScreen() }
            }
        }
    }
}



@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DrawerContent(navController: NavController, drawerState: DrawerState) {
    val scope = rememberCoroutineScope()

    ModalDrawerSheet {
        Column(modifier = Modifier.padding(16.dp)) {
            Text("Menu", style = MaterialTheme.typography.headlineSmall)
            Spacer(modifier = Modifier.height(16.dp))

            NavigationDrawerItem(
                icon = { Icon(Icons.Default.Home, contentDescription = "Strona g≈Ç√≥wna") },
                label = { Text("Strona g≈Ç√≥wna") },
                selected = false,
                onClick = {
                    navController.navigate(AppDestinations.HOME)
                    scope.launch { drawerState.close() }
                }
            )
            NavigationDrawerItem(
                icon = { Icon(Icons.Default.Person, contentDescription = "Profil") },
                label = { Text("Profil") },
                selected = false,
                onClick = {
                    navController.navigate(AppDestinations.PROFILE)
                    scope.launch { drawerState.close() }
                }
            )
            NavigationDrawerItem(
                icon = { Icon(Icons.Default.Settings, contentDescription = "Ustawienia") },
                label = { Text("Ustawienia") },
                selected = false,
                onClick = {
                    navController.navigate(AppDestinations.SETTINGS)
                    scope.launch { drawerState.close() }
                }
            )
        }
    }
}
\end{minted}

\subsection{Zagnie≈ºd≈∫ona Nawigacja}

Przejd≈∫my do drugiego przyk≈Çadu w kt√≥rym zapoznamy siƒô z ideƒÖ tworzenia zagnie≈ºd≈ºonych graf√≥w nawigacyjnych.

Za≈Ç√≥≈ºmy, ≈ºe nasza aplikacja ma wiƒôcej ni≈º trzy proste ekrany. Prawie ka≈ºda komercyjna aplikacja ma co najmniej dwa odrƒôbne \textit{przep≈Çywy} (flows):
\begin{itemize}
  \item Przep≈Çyw Uwierzytelniania: Logowanie, Rejestracja, Resetowanie Has≈Ça.
  \item G≈Ç√≥wny Przep≈Çyw Aplikacji: Ekran g≈Ç√≥wny, Profil, Ustawienia, itd.
\end{itemize}

Problem polega na tym, ≈ºe te dwa przep≈Çywy majƒÖ zupe≈Çnie inne zasady. Co najwa≈ºniejsze: gdy u≈ºytkownik pomy≈õlnie siƒô zaloguje, powinien przej≈õƒá do ekranu g≈Ç√≥wnego, a ca≈Çy przep≈Çyw uwierzytelniania powinien zniknƒÖƒá z historii. Naci≈õniƒôcie przycisku \textit{Wstecz} na ekranie g≈Ç√≥wnym nie powinno cofaƒá do ekranu logowania, lecz zamykaƒá aplikacjƒô. OsiƒÖgnƒÖƒá to mo≈ºna za pomocƒÖ zagnie≈ºd≈ºonej nawigacji.

Przeanalizujmy prosty przyk≈Çad pokazujƒÖcy takie rozwiƒÖzanie. Zamiast traktowaƒá \texttt{NavHost} jak jeden wielki kontener, traktujemy go jak folder, kt√≥ry mo≈ºe zawieraƒá zar√≥wno pojedyncze pliki (ekrany), jak i inne foldery (zagnie≈ºd≈ºone grafy).

Pierwszym krokiem jest zdefiniowanie tras w obiekcie \texttt{AppDestinations}:

\begin{minted}{kotlin}
data object AppDestinations {
    // Grafy
    const val AUTH_GRAPH = "auth_graph"
    const val MAIN_APP_GRAPH = "main_app_graph"

    // Ekrany uwierzytelniania
    const val LOGIN = "login"
    const val REGISTER = "register"
    const val FORGOT_PASSWORD = "forgot_password"

    // G≈Ç√≥wne ekrany aplikacji
    const val WELCOME = "welcome"
    const val PROFILE = "profile"
}
\end{minted}

Zauwa≈ºmy, ≈ºe nasza aplikacja bƒôdzie mia≈Ça dwa g≈Ç√≥wne podgrafy: \texttt{AUTH\_GRAPH} i \texttt{MAIN\_APP\_GRAPH}

Sp√≥jrzmy na g≈Ç√≥wny \texttt{NavHost} w \texttt{SimpleNestedNavApp}. Jest on uderzajƒÖco prosty:

\begin{minted}{kotlin}
NavHost(
    navController = navController,
    startDestination = AppDestinations.AUTH_GRAPH
) {
    // Graf uwierzytelniania (logowanie, rejestracja, itp.)
    authGraph(navController)

    // G≈Ç√≥wny graf aplikacji po zalogowaniu
    mainAppGraph(navController)
}
\end{minted}

Zauwa≈ºmy:
\begin{enumerate}
\item \texttt{startDestination} nie jest ekranem. Jest to \texttt{AUTH\_GRAPH}, czyli ca≈Çy zagnie≈ºd≈ºony graf. Aplikacja uruchamia siƒô, wchodzƒÖc do \textit{folderu} uwierzytelniania.
\item WewnƒÖtrz \texttt{NavHost} nie ma ani jednego composable() definiujƒÖcego ekran. Zamiast tego, sƒÖ tylko dwie funkcje (authGraph i mainAppGraph), kt√≥re definiujƒÖ ca≈Çe grupy ekran√≥w.
\end{enumerate}

G≈Ç√≥wny \texttt{NavHost} nie musi \textit{wiedzieƒá} nic o ekranie logowania czy profilu; musi tylko \textit{wiedzieƒá} o istnieniu \textit{przep≈Çywu uwierzytelniania} i \textit{przep≈Çywu g≈Ç√≥wnego}.

W jaki spos√≥b definiowaƒá grafy zagnie≈ºd≈ºone? S≈Çu≈ºy do tego funkcja kompozycyjna \texttt{navigation()}. Standardowo tworzy siƒô funkcje rozszerzajƒÖce dla \texttt{NavGraphBuilder}:

\begin{minted}{kotlin}
fun NavGraphBuilder.authGraph(navController: NavController) {
    navigation(
        startDestination = AppDestinations.LOGIN,
        route = AppDestinations.AUTH_GRAPH
    ) {
        composable(AppDestinations.LOGIN) {
            LoginScreen(navController) }
        composable(AppDestinations.REGISTER) {
            RegisterScreen(navController) }
        composable(AppDestinations.FORGOT_PASSWORD) {
            ForgotPasswordScreen(navController) }
    }
}

fun NavGraphBuilder.mainAppGraph(navController: NavController) {
    navigation(
        startDestination = AppDestinations.WELCOME,
        route = AppDestinations.MAIN_APP_GRAPH
    ) {
        composable(AppDestinations.WELCOME) {
            WelcomeScreen(navController) }
        composable(AppDestinations.PROFILE) {
            ProfileScreen(navController) }
    }
}
\end{minted}

Analiza tego bloku jest kluczowa:
\begin{itemize}
\item \texttt{fun NavGraphBuilder.authGraph(...)}: To czysta organizacja kodu. Zamiast za≈õmiecaƒá \texttt{NavHost}, grupujemy logikƒô w oddzielnej funkcji.
\item \texttt{navigation(...)}: To jest w≈Ça≈õciwy konstruktor zagnie≈ºd≈ºonego grafu.
\item \texttt{route = AppDestinations.AUTH\_GRAPH}: Nadajemy ca≈Çemu \textit{folderowi} nazwƒô. Teraz mo≈ºemy nawigowaƒá \textit{do} niego.
\item \texttt{startDestination = AppDestinations.LOGIN}: Definiujemy, kt√≥ry ekran jest domy≈õlny wewnƒÖtrz tego grafu.
\end{itemize}

IdentycznƒÖ strukturƒô ma \texttt{mainAppGraph}, kt√≥ry grupuje ekrany \texttt{WELCOME} i \texttt{PROFILE}.

Mamy dwa oddzielne ≈õwiaty: \texttt{AUTH\_GRAPH} i \texttt{MAIN\_APP\_GRAPH}. Jak przeskoczyƒá z jednego do drugiego i ‚Äì co najwa≈ºniejsze ‚Äì posprzƒÖtaƒá po sobie?

Sp√≥jrzmy na funkcjƒô \texttt{navigateToMainApp()}, wywo≈ÇywanƒÖ po pomy≈õlnym logowaniu:

\begin{minted}{kotlin}
fun NavController.navigateToMainApp() {
    this.navigate(AppDestinations.MAIN_APP_GRAPH) {
        popUpTo(AppDestinations.AUTH_GRAPH) {
            inclusive = true
        }
    }
}
\end{minted}

To jest najwa≈ºniejszy fragment kodu w ca≈Çym przyk≈Çadzie. Rozbijmy go na czƒô≈õci:
\begin{itemize}
\item \texttt{navigate(AppDestinations.MAIN\_APP\_GRAPH)}: M√≥wimy \textit{nawiguj do grafu g≈Ç√≥wnego}. \texttt{NavController} automatycznie skieruje nas do \texttt{startDestination} tego grafu (czyli \texttt{WELCOME}).
\item \texttt{popUpTo(AppDestinations.AUTH\_GRAPH)}: To jest polecenie \textit{sprzƒÖtajƒÖce}. Powraca na stosie a≈º znajdzie \texttt{AUTH\_GRAPH}
\item \texttt{inclusive = true}: Po znalezieniu na stosie \texttt{AUTH\_GRAPH} jest on r√≥wnie≈º usuwany.
\end{itemize}

Co siƒô dzieje w praktyce? U≈ºytkownik klika \textit{Zaloguj}. \texttt{NavController}:
\begin{itemize}
\item Znajduje na stosie powrotu graf \texttt{AUTH\_GRAPH}.
\item Usuwa ze stosu \texttt{LOGIN, REGISTER, FORGOT\_PASSWORD...} i sam \texttt{AUTH\_GRAPH}.
\item Dodaje na stos \texttt{MAIN\_APP\_GRAPH} (z ekranem \texttt{WELCOME}).
\end{itemize}

Stos powrotu jest czysty. Zawiera tylko \texttt{MAIN\_APP\_GRAPH}. Je≈õli u≈ºytkownik naci≈õnie teraz przycisk \textit{Wstecz}, nie wr√≥ci do ekranu logowania. Opu≈õci aplikacjƒô. OsiƒÖgnƒôli≈õmy dok≈Çadnie taki przep≈Çyw, jakiego oczekujƒÖ u≈ºytkownicy.

Zagnie≈ºd≈ºona nawigacja to nie jest skomplikowana funkcja dla zaawansowanych. To podstawowe narzƒôdzie do organizacji w ka≈ºdej aplikacji, kt√≥ra ma wiƒôcej ni≈º jeden logiczny przep≈Çyw. Jak widzieli≈õmy w kodzie, ten wzorzec zapewnia trzy kluczowe korzy≈õci:
\begin{enumerate}
\item Organizacjƒô: Grupuje powiƒÖzane ekrany.
\item Modularno≈õƒá: Utrzymuje g≈Ç√≥wny \texttt{NavHost} czysty i pozwala definiowaƒá przep≈Çywy w oddzielnych funkcjach.
\item Kontrolƒô nad Stosem Powrotu: Umo≈ºliwia nawigowanie miƒôdzy ca≈Çymi przep≈Çywami i usuwanie ich z historii jednym poleceniem.
\end{enumerate}

\subsubsection{Pe≈Çny kod przyk≈Çadu}

\begin{minted}{kotlin}
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            NestedComposeGraphTheme {
                SimpleNestedNavApp()
            }
        }
    }
}

data object AppDestinations {
    // Grafy
    const val AUTH_GRAPH = "auth_graph"
    const val MAIN_APP_GRAPH = "main_app_graph"

    // Ekrany autentykacji
    const val LOGIN = "login"
    const val REGISTER = "register"
    const val FORGOT_PASSWORD = "forgot_password"

    // G≈Ç√≥wne ekrany aplikacji
    const val WELCOME = "welcome"
    const val PROFILE = "profile"
}

@Composable
fun SimpleNestedNavApp() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        startDestination = AppDestinations.AUTH_GRAPH
    ) {
        // Graf autentykacji (logowanie, rejestracja, itp.)
        authGraph(navController)

        // G≈Ç√≥wny graf aplikacji po zalogowaniu
        mainAppGraph(navController)
    }
}

fun NavGraphBuilder.authGraph(navController: NavController) {
    navigation(
        startDestination = AppDestinations.LOGIN,
        route = AppDestinations.AUTH_GRAPH
    ) {
        composable(AppDestinations.LOGIN) {
            LoginScreen(navController) }
        composable(AppDestinations.REGISTER) {
            RegisterScreen(navController) }
        composable(AppDestinations.FORGOT_PASSWORD) {
            ForgotPasswordScreen(navController) }
    }
}

fun NavGraphBuilder.mainAppGraph(navController: NavController) {
    navigation(
        startDestination = AppDestinations.WELCOME,
        route = AppDestinations.MAIN_APP_GRAPH
    ) {
        composable(AppDestinations.WELCOME) {
            WelcomeScreen(navController) }
        composable(AppDestinations.PROFILE) {
            ProfileScreen(navController) }
    }
}

@Composable
fun LoginScreen(navController: NavController) {
    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Logowanie", fontSize = 28.sp)
        Spacer(Modifier.height(24.dp))
        Button(onClick = { navController.navigateToMainApp() }) {
            Text("Zaloguj")
        }
        Spacer(Modifier.height(12.dp))
        Button(onClick = { navController.navigate(AppDestinations.REGISTER) }) {
            Text("Przejd≈∫ do Rejestracji")
        }
        Spacer(Modifier.height(12.dp))
        TextButton(onClick = { navController.navigate(AppDestinations.FORGOT_PASSWORD) }) {
            Text("Zapomnia≈Çem has≈Ça")
        }
    }
}

@Composable
fun RegisterScreen(navController: NavController) {
    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Rejestracja", fontSize = 28.sp)
        Spacer(Modifier.height(24.dp))
        Button(onClick = { navController.navigateToMainApp() }) {
            Text("Zarejestruj i zaloguj")
        }
        Spacer(Modifier.height(12.dp))
        TextButton(onClick = { navController.popBackStack() }) {
            Text("Wr√≥ƒá do logowania")
        }
    }
}

@Composable
fun ForgotPasswordScreen(navController: NavController) {
    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Resetowanie Has≈Ça", fontSize = 24.sp, textAlign = TextAlign.Center)
        Spacer(Modifier.height(24.dp))
        Button(onClick = { navController.popBackStack() }) {
            Text("Powr√≥t")
        }
    }
}
@Composable
fun WelcomeScreen(navController: NavController) {
    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Witaj w Aplikacji! üéâ", fontSize = 28.sp)
        Spacer(Modifier.height(24.dp))
        Button(onClick = { navController.navigate(AppDestinations.PROFILE) }) {
            Text("Zobacz m√≥j profil")
        }
    }
}

@Composable
fun ProfileScreen(navController: NavController) {
    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Ekran Profilu üßë‚Äçüíª", fontSize = 28.sp)
        Spacer(Modifier.height(24.dp))
        Button(onClick = { navController.popBackStack() }) {
            Text("Wr√≥ƒá do ekranu powitalnego")
        }
    }
}

fun NavController.navigateToMainApp() {
    this.navigate(AppDestinations.MAIN_APP_GRAPH) {
        popUpTo(AppDestinations.AUTH_GRAPH) {
            inclusive = true
        }
    }
}
\end{minted}
